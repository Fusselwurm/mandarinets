import { MandarineMVC } from "../mvc-framework/mandarineMVC.ts";
import { MandarineCore } from "./mandarineCore.ts";
import { MandarineEnvironmentalConstants } from "./MandarineEnvConstants.ts";
import { expandGlobSync } from "https://deno.land/std@0.71.0/fs/mod.ts";
import { readDecoratorsExportedClass, DecoratorReadResult } from "./utils/decoratorFinder.ts";
import { MandarineConstants } from "./mandarineConstants.ts";

export class App {

    public setHost(host: string): App {
        Deno.env.set(MandarineEnvironmentalConstants.MANDARINE_SERVER_HOST, host);
        return this;
    }

    public setPort(port: number): App {
        Deno.env.set(MandarineEnvironmentalConstants.MANDARINE_SERVER_PORT, port.toString());
        return this;
    }

    public enableResponseTimeHeader(): App {
        Deno.env.set(MandarineEnvironmentalConstants.MANDARINE_SERVER_RESPONSE_TIME_HEADER, "true");
        return this;
    }

    public enableSessions(): App {
        Deno.env.set(MandarineEnvironmentalConstants.MANDARINE_SERVER_SESSION_MIDDLEWARE, "true");
        return this;
    }

    public setStaticContentFolder(folderPath: string): App {
        Deno.env.set(MandarineEnvironmentalConstants.MANDARINE_STATIC_CONTENT_FOLDER, folderPath);
        return this;
    }

    public setAuthExpirationTime(expirationTimeMs: number): App {
        Deno.env.set(MandarineEnvironmentalConstants.MANDARINE_AUTH_EXPIRATION_MS, expirationTimeMs.toString());
        return this;
    }

    public buildCore(components: Array<{ new (): any }>): MandarineCore {
        // This function does nothing. We only need to import the references and Mandarine will do its magic.
        return new MandarineCore();
    }

    public buildMVC(components: Array<{ new (): any }>): MandarineMVC {
        // This function does nothing. We only need to import the references and Mandarine will do its magic.
        return new MandarineCore().MVC();
    }

    public automaticBuildAndRun() {
        const entries: Map<string, Array<DecoratorReadResult>> = new Map<string, Array<DecoratorReadResult>>();
        const decoder: TextDecoder = new TextDecoder();

        for (const file of expandGlobSync("./**/*.ts")) {
            const path = file.path;
            const decorators = readDecoratorsExportedClass(decoder.decode(Deno.readFileSync(path)));
            if(decorators !== null) {
                const insertionDecorators = decorators.map(decorator =>  { decorator.filePath = path; return decorator; });
                entries.set(path, decorators.map(decorator =>  { decorator.filePath = path; return decorator; }));
            }
        }

        let decoratorsArray: Array<DecoratorReadResult> = new Array<DecoratorReadResult>();
        Array.from(entries.values()).forEach((decoratorResults: Array<DecoratorReadResult>) => {
            decoratorsArray = decoratorsArray.concat(decoratorResults);
        });

        let dynamicEntryFile = `import { MandarineCore } from "https://deno.land/x/mandarinets@${MandarineConstants.RELEASE_VERSION}/mod.ts";`;

        const classNameRepetitions = (className: string) => decoratorsArray.filter(decorator => decorator.className === className).length;
        const isClassNameRepeated = (className: string): boolean => classNameRepetitions(className) >= 2;

        const repetitionStats: { [prop: string]: { current: number, maxRepetitions: number }} = {};

        decoratorsArray.forEach((value: DecoratorReadResult, index: number) => {
            const { className } = value;
            let asClassName = undefined;
            if(isClassNameRepeated(className)) {
                if(!repetitionStats[className]) {
                    repetitionStats[className] = {
                        current: 0,
                        maxRepetitions: classNameRepetitions(className)
                    }
                } else {
                    repetitionStats[className].current += 1;
                    asClassName = `${className}${repetitionStats[className].current}`;
                }
                value.asClassName = asClassName;
            }

            decoratorsArray[index] = value;
        });

        decoratorsArray.forEach((value: DecoratorReadResult) => {
            let currentClassName = value.asClassName ? `${value.className} as ${value.asClassName}` : value.className;
            const importName = value.isDefault ?  currentClassName : `{ ${currentClassName} }`;
            dynamicEntryFile = dynamicEntryFile.concat(`\nimport ${importName} from "${value.filePath}"\n`);
        });

        dynamicEntryFile = dynamicEntryFile.concat(`\nconst MANDARINE_AUTOGENERATED_COMPONENTS_LIST = [${decoratorsArray.map(item => item.asClassName || item.className).join(", ")}];\n`); // NEW LINE

        dynamicEntryFile = dynamicEntryFile.concat('\nnew MandarineCore().MVC().run();\n');

        const targetFileName = `./${MandarineConstants.MANDARINE_TARGET_FOLDER}/target.ts`;
        //Deno.mkdirSync(MandarineConstants.MANDARINE_TARGET_FOLDER);
        Deno.writeFileSync(targetFileName, new TextEncoder().encode(dynamicEntryFile));

        Deno.run({
            stderr: "inherit",
            stdin: "inherit",
            stdout: "inherit",
            cmd: ["deno", "run", "--allow-all", targetFileName]
        }).status();
        
    }
}

